extern crate fountaincode;
extern crate rand;

use self::fountaincode::soliton::Soliton;
use rand::{rngs::StdRng, Rng, SeedableRng};

#[test]
fn soliton_compare_test() {
    // Once we have done enough iterations,
    // The random numbers getting generated by RobustSoliton must total higher than IdealSoliton
    // Simply because IdealSoliton favors "small" degrees, whereas RobustSoliton favors both "small"
    // and "large" degrees. But who the hell knows...

    let tot_iterations = 10000;
    let mut rng = StdRng::from_entropy();
    let cnt_blocks = 100;
    let mut sol = Soliton::ideal(cnt_blocks, rng.gen::<u64>());
    let mut rsol = Soliton::robust(cnt_blocks, rng.gen::<u64>(), 0.2, None, 0.05);
    let mut rsol2 = Soliton::robust(cnt_blocks, rng.gen::<u64>(), 0.2, Some(40), 0.05);

    // println!("sol: {:#?}", sol);
    // println!("rsol: {:#?}", rsol);
    // println!("rsol2: {:#?}", rsol2);

    let mut i_sum = 0;
    let mut r_sum = 0;
    let mut r_sum2 = 0;

    for _ in 1..tot_iterations {
        let i_next = sol.gen();
        let r_next = rsol.gen();
        let r2_next = rsol2.gen();
        i_sum += i_next;
        r_sum += r2_next;
        r_sum2 += r2_next;
        println!(
            "i_next: {:?}, r_next: {:?}, r2_next: {:?}",
            i_next, r_next, r2_next
        );
    }

    println!("i_sum: {:?}", i_sum);
    println!("r_sum: {:?}", r_sum);
    println!("r_sum2: {:?}", r_sum2);
    assert!(r_sum > i_sum)
}
