extern crate fountaincode;
extern crate rand;

use self::fountaincode::ideal_soliton::IdealSoliton;
use self::fountaincode::robust_soliton::RobustSoliton;
use rand::{rngs::StdRng, Rng, SeedableRng};

#[test]
fn soliton_compare_test() {

    // Once we have done enough iterations,
    // The random numbers getting generated by RobustSoliton must total higher than IdealSoliton
    // Simply because IdealSoliton favors "small" degrees, whereas RobustSoliton favors both "small"
    // and "large" degrees.

    let tot_iterations = 10000;
    let mut rng = StdRng::from_entropy();
    let cnt_blocks = 100;
    let mut sol = IdealSoliton::new(cnt_blocks, rng.gen::<u64>());
    let mut rsol = RobustSoliton::new(cnt_blocks, rng.gen::<u64>(), 0.2, None, 0.05);
    let mut rsol2 = RobustSoliton::new(cnt_blocks, rng.gen::<u64>(), 0.2, Some(40), 0.05);

    println!("sol: {:#?}", sol);
    println!("rsol: {:#?}", rsol);
    println!("rsol2: {:#?}", rsol2);

    let mut i_sum = 0;
    let mut r_sum = 0;
    let mut r_sum2 = 0;

    for _ in 1..tot_iterations {
        // println!("isol next: {:?}", sol.next())
        // println!("rsol next: {:?}", rsol.next())
        i_sum += sol.next().unwrap();
        r_sum += rsol.next().unwrap();
        r_sum2 += rsol2.next().unwrap();
        println!("rsol2: {:#?}", rsol2);
    }

    println!("i_sum: {:?}", i_sum);
    println!("r_sum: {:?}", r_sum);
    println!("r_sum2: {:?}", r_sum2);
    assert!(r_sum > i_sum)
}
